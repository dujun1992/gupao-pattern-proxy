【为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？】
1、Class文件是一组以8字节为基础单位的二进制流。
2、Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表接口索引计数器(interfaces_count)，占2字节。
3、所以，证明interface_count的数量最多是2^16次方，最大值=65535。

【代理模式】
1、为其他对象提供一种代理，以控制对这个对象的访问。
2、代理对象持有被代理对象的引用（接口或者类），代理对象产生的新实例也拥有被代理对象的方法（该新的实例实现了接口或者是子类重写的方法）客户端调用代理对象方法，同时也调用被代理对象的方法，只是在代理对象前后增加一些处理。
3、代理模式属于结构型模式，有静态代理和动态代理。 
4、使用代理模式主要有两个目的：一保护目标对象，二增强目标对象。

【静态代理】
静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。

【动态代理】
1、动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。
2、、若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。

【JDK实现方式-实现InvocationHandler接口，字节码重组】
1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。
2、JDKProxy类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接
口。
3、动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用。
4、编译新生成的Java代码.class。
5、再重新加载到JVM内存中运行，生成新的类。

【CGLib实现方式-实现MethodInterceptor接口，采用ASM生成字节码，采用拦截器】
生成三个类（一个代理类[被代理对象的子类]，代理类FastClass类及被代理类的FastClass类）

【JDK方式与CGLib方式对比】
1、JDK动态代理是实现了被代理对象的接口，CGLib是继承了被代理对象。
2、JDK和CGLib都是在运行期生成字节码， JDK是直接写Class字节码， CGLib使用ASM
框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
3、JDK调用代理方法，是通过反射机制调用， CGLib是通过FastClass机制直接调用方法，
CGLib执行效率更高。

【代理模式优缺点】
使用代理模式具有以下几个优点：
1、代理模式能将代理对象与真实被调用的目标对象分离。
2、一定程度上降低了系统的耦合度，扩展性好。
3、可以起到保护目标对象的作用。
4、可以对目标对象的功能增强。
当然，代理模式也是有缺点的：
1、代理模式会造成系统设计中类的数量增加。
2、在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。
3、增加了系统的复杂度。

【Spring中的代理-ProxyFactoryBean】
在Spring的配置中，如果不做任何设置，那么Spring代理生成的Bean都是单例对象。
如果修改scope则每次创建一个新的原型对象。
1、当Bean有实现接口时，Spring就会用JDK的动态代理
2、当Bean没有实现接口时，Spring选择CGLib。
Spring可以通过配置强制使用CGLib，只需在Spring的配置文件中加入如下代码：
  <aop:aspectj-autoproxy proxy-target-class="true"/> 
